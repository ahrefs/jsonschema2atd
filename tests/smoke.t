Generate ATD out of JSON Scheme
  $ jsonschema2atd ./mocks/simple_jsonschema.json
  (* Generated by jsonschema2atd *)
  type json <ocaml module="Yojson.Basic" t="t"> = abstract
  type int64 = int <ocaml repr="int64">
  
  type product = {
    ?productId <doc text="The unique identifier for a product">: int option;
  } 
Generate ATD out of JSON Scheme with --format attribute
  $ jsonschema2atd --format jsonschema ./mocks/simple_jsonschema.json
  (* Generated by jsonschema2atd *)
  type json <ocaml module="Yojson.Basic" t="t"> = abstract
  type int64 = int <ocaml repr="int64">
  
  type product = {
    ?productId <doc text="The unique identifier for a product">: int option;
  } 
Generate ATD out of JSON Scheme with -f attribute
  $ jsonschema2atd -f jsonschema ./mocks/simple_jsonschema.json
  (* Generated by jsonschema2atd *)
  type json <ocaml module="Yojson.Basic" t="t"> = abstract
  type int64 = int <ocaml repr="int64">
  
  type product = {
    ?productId <doc text="The unique identifier for a product">: int option;
  } 
Generate ATD out of OpenAPI doc with --format attribute
  $ jsonschema2atd --format openapi ./mocks/simple_openapi.json
  (* Generated by jsonschema2atd *)
  type json <ocaml module="Yojson.Basic" t="t"> = abstract
  type int64 = int <ocaml repr="int64">
  
  type product = {
    ?productId <doc text="The unique identifier for a product">: int option;
  } 
Generate ATD out of OpenAPI doc with -f attribute
  $ jsonschema2atd -f openapi ./mocks/simple_openapi.json
  (* Generated by jsonschema2atd *)
  type json <ocaml module="Yojson.Basic" t="t"> = abstract
  type int64 = int <ocaml repr="int64">
  
  type product = {
    ?productId <doc text="The unique identifier for a product">: int option;
  } 

Generate ATD out of JSON Schema that contains defs
  $ jsonschema2atd --format=jsonschema ./mocks/jsonchema_defs.json
  (* Generated by jsonschema2atd *)
  type json <ocaml module="Yojson.Basic" t="t"> = abstract
  type int64 = int <ocaml repr="int64">
  
  type name = string 
  
  type root = {
    first_name : name;
    last_name : name;
  } 

Generate ATD out of JSON Schema that contains definitions (legacy support)
  $ jsonschema2atd --format=jsonschema ./mocks/jsonchema_definitions.json
  (* Generated by jsonschema2atd *)
  type json <ocaml module="Yojson.Basic" t="t"> = abstract
  type int64 = int <ocaml repr="int64">
  
  type name = string 
  
  type root = {
    first_name : name;
    last_name : name;
  } 

Generate ATD out of JSON Schema that uses references
  $ jsonschema2atd --format=jsonschema ./mocks/jsonschema_refs.json
  (* Generated by jsonschema2atd *)
  type json <ocaml module="Yojson.Basic" t="t"> = abstract
  type int64 = int <ocaml repr="int64">
  
  type root = {
    first_name : string;
    last_name : string;
    shipping_address : address;
    billing_address : address;
    ?aa : address option;
    ?bb : address option;
    ?cc : address option;
    ?dd : address option;
    ?ee : address option;
    ?ff : address option;
  } 

Generate ATD out of JSON Schema that uses enums
  $ jsonschema2atd --format=jsonschema ./mocks/jsonschema_enums.json
  (* Generated by jsonschema2atd *)
  type json <ocaml module="Yojson.Basic" t="t"> = abstract
  type int64 = int <ocaml repr="int64">
  
  type rootMyProperty = [
    | Foo <json name="foo">
    | Bar <json name="bar">
  ] 
  
  type rootMyPropertyInt = int 
  
  type rootMyPropertyNumber = float 
  
  type rootMyPropertyBool = bool 
  
  type root = {
    myProperty : rootMyProperty;
    ?myPropertyInt : rootMyPropertyInt option;
    ?myPropertyNumber : rootMyPropertyNumber option;
    ?myPropertyBool : rootMyPropertyBool option;
  } 
